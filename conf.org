#+TITLE: conf.org
#+AUTHOR: Tom Hutchings
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

This is my init.el, except its written in org mode. 

* init.el
  =init.el= is a short file that simply tangles, loads, and compiles the =conf.org= file (/this one/). For annoying autoload related reasons it also has the =straight.el= bootstrap code in it.

* Packages
   We now use a combination of use-package and straight.el to manage packages. This gives a nice functional/declarative style of package management. Way better than trying to remember what is installed on which computer, and having to constantly call =package-install-selected-packages= on every new machine.

   +This is the bootstrap code for straight.el+ Due to org autoloading reasons, we have to put the bootstrap code for straight.el into =init.el=

    I also want to set up =use-package=, which works in conjuntion with =straight.el=.

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'use-package)
#+END_SRC

* Local Files
   Sometimes you start emacs from a shortcut, and it'll put itself in the wrong directory. This starts us in home.

#+BEGIN_SRC emacs-lisp
  (setq default-directory (concat (getenv "HOME") "/"))
#+END_SRC

   The =custom-file= must be set so as not to pollute our init.el with =custom-set-definitions=.
   In the =/lisp= directory I keep any standalone lisp files, such as major and minor modes I wrote.
   =/colors= has any custom color schemes I've picked up that don't exist in melpa.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (concat user-emacs-directory  "custom.el"))
  (load custom-file)
  (add-to-list 'load-path (concat user-emacs-directory "lisp/"))
  (add-to-list 'custom-theme-load-path (concat user-emacs-directory "colors/"))
#+END_SRC

* Editor config
  Here we configure the emacs text editor itself, the old fashioned bitch. Lots of this is just disabling menu bars, scroll bars, bells, cursors yada yada yada...

*** waifu-mode
    Ain't this a gem. It's a kind of image viewer, it picks random images from a given folder and shows them onscreen.
#+BEGIN_SRC emacs-lisp
  ;; (require 'waifu)
  ;; (waifu-keybind-to-dir
  ;;  '(("m" "~/Pictures/animu/madoka_magica/madoka")
  ;;    ("h" "~/Pictures/animu/madoka_magica/homura")
  ;;    ("s" "~/Pictures/animu/madoka_magica/sayaka")
  ;;    ("k" "~/Pictures/animu/madoka_magica/kyouko")
  ;;    ("M" "~/Pictures/animu/madoka_magica/mami")
  ;;    ("v" "~/Pictures/animu/gabriel_dropout/vigne")
  ;;    ("f" "~/Pictures/animu/re_zero/felix")
  ;;    ("p" "~/Pictures/animu/proggybooks")))
#+END_SRC

*** Themes, font, prettifying
    First we'll install the theme packages, and install doom-themes, loading fairy-floss cause its dope.

#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :straight t
    ;; :init (load-theme 'doom-fairy-floss t)
    )

  (straight-use-package 'olivetti)
  (straight-use-package 'all-the-icons)

   (use-package tao-theme
      :straight t
      :init
      (load-theme 'tao-yang t))
#+END_SRC

    Theme picker. I can add themes I like the the list =tokamach/themes= and choose from them when I want. I realised I changed themes quite a lot, not least in the morning and evening I switch between a light and dark theme.

#+BEGIN_SRC emacs-lisp
  (defvar tokamach/themes '(
			    ;; Dark Themes
			    base16-atlas
			    purple-haze
			    soothe

			    ;; Light Themes
			    base16-atelier-estuary-light
			    parchment
			    plan9
			    anti-zenburn))

  (defun tokamach/pick-theme ()
    "Present a list of themes for user to pick"
    (interactive)
    (ivy-read
     "Pick theme:"
     tokamach/themes 
     :require-match t
     ;; :initial-input (car custom-enabled-themes)
     :action (lambda (theme)
	       (progn
		 (mapc #'disable-theme custom-enabled-themes)
		 (load-theme (intern theme) t)
		 (fringe-mode 0)))
     :update-fn (lambda ()
		  (progn (mapc #'disable-theme custom-enabled-themes)
			 (load-theme (nth ivy--index tokamach/themes) t)
			 (fringe-mode 0)))))
#+END_SRC

    Setting the font is pretty self explanatory. I've used Anonymous Pro for ages, it's pretty good at distinguishing 0/o, i/L, etc.

#+BEGIN_SRC emacs-lisp
  ;; fonts
  (set-frame-font "Anonymous Pro 13" nil t)
#+END_SRC

    This sections a doozy. Welcome to emacs in the 21st century. Basically we just have to disable all the ugly stuff emacs has by default, like menu bars. Who needs 'em; I have M-x, I have keybinds. Visible bell aka /SHUT THE FUCK UP EMACS/, inhibit startup because I know I'm using /"GNU Emacs, one component of the GNU/Linux operating system"/, turn off scroll bars and the weird fringes. Also =doom-modeline= makes the modeline look all nice.

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
  (setq visible-bell t)
  (setq ring-bell-function 'ignore)
  (setq initial-scratch-message "")
  (setq inhibit-startup-message t)
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode 0)
  (fringe-mode 0)
  (setq frame-title-format "%b")

  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  ;(add-to-list 'default-frame-alist '(ns-appearance . dark))
  (add-to-list 'default-frame-alist '(ns-appearance . light))

  ;; better modeline
  (use-package doom-modeline
    :straight t
    :hook (after-init . doom-modeline-mode))
#+END_SRC

*** Homepage
Opening emacs only to be greeted by a blank =*scratch*= isn't fun. How about a cool startup page.

#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :straight t)
  (require 'dashboard)

  (let ((imgs (file-expand-wildcards (concat user-emacs-directory "/dashboard-images/*.png")))
	(random-choice (lambda (elems)
			 (let* ((size (length elems))
				(index (random size)))
			   (nth index elems)))))
    (setq dashboard-startup-banner (funcall random-choice imgs)))

  (setq dashboard-banner-logo-title "You're slacking off instead of writing Lisp? Pretty cringe bro.")
  (setq dashboard-center-content t)
  (setq show-week-agenda-p t)
  (setq dashboard-items '((recents  . 5)
			  (agenda   . 5)
			  (projects . 5)))
  (setq dashboard-footer nil)

  (dashboard-setup-startup-hook)
  (setq inital-buffer-choice (lambda () (get-buffer "*dashboard*")))
#+END_SRC

*** Editor functionality
    Most of this is pretty self-explanatory. Tramp wants to use ssh, ispell exists actually (thanks macOS for being macOS), smooth scrolling is nice, undo-tree everywhere, oh and please stop spewing backup files all over my file system.

#+BEGIN_SRC emacs-lisp
  ;; tramp
  (setq tramp-default-method "ssh")

  ;; flyspell
  (setq ispell-program-name "/usr/local/bin/ispell")

  ;; smooth scroll
  (straight-use-package 'smooth-scrolling)
  (require 'smooth-scrolling)
  (smooth-scrolling-mode 1)

  (straight-use-package 'undo-tree)
  (global-undo-tree-mode)

  ;; stop backups
  (setq backup-inhibited t
	make-backup-files nil
	auto-save-default nil)
#+END_SRC

*** Editor key bindings
    Most of my more specific key bindings are stored in =modal-soul.el=, a set of hydras which simulate a kind of modal-editing system ala vim. Other stuff here is just avy and setting up the ivy/counsel/swiper trinity.

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'hydra)
  ;; modal-soul, my hydras
  (straight-use-package 'buffer-move)
  (load "~/.emacs.d/lisp/modal-soul.el")

  (straight-use-package 'which-key)
  (which-key-mode)

  ;; avy bindings
  ;; (global-set-key (kbd "C-l") 'avy-goto-line)
#+END_SRC

*** Ivy
    Ivy is a minibuffer completion framework, much nicer than the built in emacs completion. 
#+BEGIN_SRC emacs-lisp
  ;; ivy/counsel/swiper
  (straight-use-package 'counsel)
  (global-set-key "\C-s" 'swiper)
  (counsel-mode)
  (setq projectile-completion-system 'ivy)
#+END_SRC

*** Magit
#+BEGIN_SRC emacs-lisp
(straight-use-package 'magit)
#+END_SRC

*** Projectile
#+BEGIN_SRC emacs-lisp
(straight-use-package 'projectile)
#+END_SRC


*** Minions
#+BEGIN_SRC emacs-lisp
  (use-package minions
    :straight t
    :config (minions-mode 1))
#+END_SRC

*** Treemacs
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'all-the-icons)
  (straight-use-package 'treemacs)
#+END_SRC
* Org mode
As I spend so much time and effort on /org mode/ I feel it deserves a whole section and a full explanation. 
** Misc Config
First though, a few org addon packages. org-bullets replaces the default =*= with nice unicode bullets and org-sidebar provides a handy sidebar overview of files.
#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :straight t
    :init (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

  (straight-use-package 'org-sidebar)
#+END_SRC

Org agenda would annoyingly mess up your windows and then not put them back. Be more like your respectable tidy brother magit.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-restore-windows-after-quit 1)
#+END_SRC

=hide-emphasis-markers= is a nice addition that shows styled text inline. Combined with variable pitch mode it makes org buffers feel more like rich text.

#+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
  ;(add-hook 'org-mode-hook 'variable-pitch-mode)
#+END_SRC

=org-indent-mode= handles indentation, or the lack thereof. Org files should be saved without indentation, and org-indent-mode will display them as if they were. Naturally its important for org-indent-mode to always be enabled, so that the lack of indentation is hidden away.

#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
#+END_SRC

** Workflow
Now we get to the good stuff. Here we'll set some useful variables for all org functions. Org directory where I keep all my org files. 
My system uses time management features like the /agenda/, =org-capture=, some /GTD/ concepts, and a combo of /Orglzy/ and /Syncthing/ to provide a comprehensive, multiplatform, planning system.

#+BEGIN_SRC emacs-lisp
  (setq tokamach/org-directory "~/doc/org/")
  (setq tokamach/org-file-list (file-expand-wildcards (concat tokamach/org-directory "*.org")))
#+END_SRC

We should modify the /TODO/ keywords to add a 'NEXT' keyword. This means a task is ongoing, and ideally should be finished before others are started.

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO" "NEXT" "|" "DONE" )))
#+END_SRC

=inbox.org= serves as a place for captured ideas to go. 

#+BEGIN_SRC emacs-lisp
  (setq org-default-notes-file (concat tokamach/org-directory "inbox.org"))
#+END_SRC

Once notes are captured to inbox.org, they must be /processed/. I will add any extra details such as deadlines, time to complete, and priority, then /refile/ them to their relevant org heading. Since all org files can be related in any weird number of ways, we shouldn't limit ourselves to only a small amount of targets. All org files (at least all in the org directory) are included, albeit only to a single heading level (for now).

#+BEGIN_SRC emacs-lisp
  (setq org-refile-targets
        (mapcar (lambda (e) `(,e . (:maxlevel . 1)))
                tokamach/org-file-list))
#+END_SRC

Sometimes I wanna use /pomodoro technique/.

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'org-pomodoro)
#+END_SRC
** Agenda 
The same principle applies to /agenda/. We should be able to put /TODO/ headings in any org file, for any project, and have them be added to the agenda. We can filter through these in the agenda config.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files tokamach/org-file-list)
#+END_SRC


The org agenda page is the heart of the entire system. Assuming all the org files are in place, and the headings are processed correctly, this should be a beautiful dashboard to manage tasks from. Largely copied from [[https://gist.github.com/jethrokuan/78936a44f249e2c1a61b5184669a32d7][this gist]] (look up the rest of Jethro Kuans stuff on this though, he's got it down).

#+BEGIN_SRC emacs-lisp
  (setq tokamach/org-agenda-view
        `(("a" "Agenda"
           ;; Today
           ((agenda ""
                    ((org-agenda-span 'day)
                     (org-agenda-overriding-header "Today")
                     (org-deadline-warning-days 365)))
            ;; The Week
            (agenda ""
                    ((org-agenda-span 'week)
                     (org-agenda-overriding-header "This Week")
                     (org-deadline-warning-days 365)))
            ;; Inbox
            (todo "TODO"
                  ((org-agenda-overriding-header "To Refile")
                   (org-agenda-files '(,(concat tokamach/org-directory "inbox.org")))))
            ;; In Progress
            (todo "NEXT"
                  ((org-agenda-overriding-header "In Progress")
                   (org-agenda-files '(,(concat tokamach/org-directory "someday.org")
                                       ,(concat tokamach/org-directory "next.org")
                                       ;; TODO: add individual projects
                                       ))))
            ;; One offs (next.org)
            (todo "TODO"
                  ((org-agenda-overriding-header "One-off Tasks")
                   (org-agenda-files '(,(concat tokamach/org-directory "next.org")))
                   (org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline 'scheduled))))
            ;; Projects
            (tags-todo ":programming:car:bike:keyboard:"
                       ((org-agenda-overriding-header "Projects")))
            ;; Personal Stuff
            (tags-todo ":house:money:work:me:"
                       ((org-agenda-overriding-header "Me")))
            nil))))

  (setq org-agenda-custom-commands `,tokamach/org-agenda-view)
  (global-set-key (kbd "C-c a") #'org-agenda)
#+END_SRC

Capturing is key to the process. Ideas can come about anywhere, anytime. Being able to quickly jot your idea down for later processing means you don't have to worry about sacrificing your current task or your forgetting your idea.
Right now there's only one capture template, /i/, which adds the idea to the inbox file with /TODO/ prefixed.

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        `(("i" "inbox" entry (file ,(concat tokamach/org-directory "inbox.org")) "* TODO %?")))

  (global-set-key (kbd "C-c c") #'org-capture)
#+END_SRC
* Language Config
  Finally we've transformed the ancient magicks of emacs from a 50 year old dusty old expensive typewriter into an elegant tool to weave the fabric of code. Or something. Now we can get to our language specific config and hooks. 

*** Company Mode
    Most of these languages provide a company mode completion system. We'll just make sure the latest version is installed here so we don't have to worry about it somwhere else.
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'company)
#+END_SRC

*** C/C++
    The siblings who don't want to be associated with each other, lumped in to the same hook once again. By default emacs formats C in a bizarre GNU way. Cool, but not for me. Or whoever else has to read my C code.
    The mode hook is to set up eglot, but since that's proved very difficult in OS dev stuff, and my main C programming is for OS dev, I just disabled it until I can be bothered.
#+BEGIN_SRC emacs-lisp
  (setq c-default-style "linux"
	c-basic-offset 4)

  (defun tokamach/c-c++-hook ()
    "Personal C/C++ hook."
    (setq company-backends
	  (cons 'company-capf
		(remove 'company-capf company-backends)))
    (eglot-ensure))

  ;(add-hook 'c-mode-hook 'tokamach/c-c++-hook)
#+END_SRC

*** Lisps
    The language of the gods finally gets its turn. Do I want intelligent context dependent structural editing? *YES*. Do I want rainbows all over my parentheses? *YES*. Gimme that good shit.

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'geiser)
  (straight-use-package 'lispy)
  (straight-use-package 'rainbow-delimiters)

  (defun tokamach/lisp-hook ()
    "Personal Lisp hook."
    (lispy-mode)
    (rainbow-delimiters-mode)
    (show-paren-mode)
    (company-mode))

  (add-hook 'emacs-lisp-mode-hook  #'tokamach/lisp-hook)
  (add-hook 'common-lisp-mode-hook #'tokamach/lisp-hook)
  (add-hook 'scheme-mode-hook      #'tokamach/lisp-hook)
  (add-hook 'lisp-mode-hook        #'tokamach/lisp-hook)

  ;; Common Lisp
  (straight-use-package 'slime)
  (straight-use-package 'slime-company)
  (require 'slime)
  (setq inferior-lisp-program "/usr/local/bin/sbcl")
  (slime-setup '(slime-fancy slime-company))
#+END_SRC

*** Latex
    This is really just wrestling with macOS. AuCTeX is really good out of the box.

#+BEGIN_SRC emacs-lisp
(straight-use-package 'auctex)
(straight-use-package 'latex-pretty-symbols)
(straight-use-package 'exec-path-from-shell)

(exec-path-from-shell-initialize)
(setq TeX-parse-self t) ; Enable parse on load.
(setq TeX-auto-save t) ; Enable parse on save.
#+END_SRC
*** Matlab
    Urgh, matlab. At least its not too bad to use from within Emacs. We've gotta tell matlab-mode where the matlab binary is, and then we get to use the shell and eval like features in Emacs.

#+BEGIN_SRC emacs-lisp
(straight-use-package 'matlab-mode)
(setq matlab-shell-command "/Applications/MATLAB_R2019a.app/bin/matlab")
(setq matlab-shell-command-switches (list "-nodesktop"))
#+END_SRC
*** C#
    We use csharp-mode for general syntax highlighting, and omnisharp for more advanced tooling.
#+BEGIN_SRC emacs-lisp
  (straight-use-package 'csharp-mode)
  (straight-use-package 'omnisharp)

  (add-hook 'csharp-mode-hook #'omnisharp-mode)
  ;(omnisharp-install-server)  ;Will do nothing if server already installed

  (eval-after-load
   'company
   '(add-to-list 'company-backends 'company-omnisharp))

  (add-hook 'csharp-mode-hook #'company-mode)
#+END_SRC
*** Swift/Xcode
    Currently non working, not tangled
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package lsp-sourcekit
    :after lsp-mode
    :config
    (setenv "SOURCEKIT_TOOLCHAIN_PATH" "/Library/Developer/Toolchains/")
    (setq lsp-sourcekit-executable (expand-file-name "/L")))
#+END_SRC
