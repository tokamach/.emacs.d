#+TITLE: conf.org
#+AUTHOR: Tom Hutchings
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes

This is my init.el, except its written in org mode. 

* init.el
  =init.el= is a short file that simply tangles, loads, and compiles the =conf.org= file (/this one/).

* Packages
   We now use a combination of use-package and straight.el to manage packages. This gives a nice functional/declarative style of package management. Way better than trying to remember what is installed on which computer, and having to constantly call =package-install-selected-packages= on every new machine.

   +This is the bootstrap code for straight.el+ Due to org autoloading reasons, we have to put the bootstrap code for straight.el into =init.el=

    I also want to set up =use-package=, which works in conjuntion with =straight.el=.

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'use-package)
#+END_SRC

*** Themes and Visual stuff

* Local Files
   Sometimes you start emacs from a shortcut, and it'll put itself in the wrong directory. This starts us in home.

#+BEGIN_SRC emacs-lisp
  (setq default-directory (concat (getenv "HOME") "/"))
#+END_SRC

   The =custom-file= must be set so as not to pollute our init.el with =custom-set-definitions=.
   In the =/lisp= directory I keep any standalone lisp files, such as major and minor modes I wrote.
   =/colors= has any custom color schemes I've picked up that don't exist in melpa.

#+BEGIN_SRC emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
  (add-to-list 'load-path "~/.emacs.d/lisp/")
  (add-to-list 'custom-theme-load-path "~/.emacs.d/colors/")
#+END_SRC

* Editor config
  Here we configure the emacs text editor itself, the old fashioned bitch. Lots of this is just disabling menu bars, scroll bars, bells, cursors yada yada yada...

*** waifu-mode
    Ain't this a gem. It's a kind of image viewer, it picks random images from a given folder and shows them onscreen.
#+BEGIN_SRC emacs-lisp
  ;; (require 'waifu)
  ;; (waifu-keybind-to-dir
  ;;  '(("m" "~/Pictures/animu/madoka_magica/madoka")
  ;;    ("h" "~/Pictures/animu/madoka_magica/homura")
  ;;    ("s" "~/Pictures/animu/madoka_magica/sayaka")
  ;;    ("k" "~/Pictures/animu/madoka_magica/kyouko")
  ;;    ("M" "~/Pictures/animu/madoka_magica/mami")
  ;;    ("v" "~/Pictures/animu/gabriel_dropout/vigne")
  ;;    ("f" "~/Pictures/animu/re_zero/felix")
  ;;    ("p" "~/Pictures/animu/proggybooks")))
#+END_SRC

*** Themes, font, prettifying
    First we'll install the theme packages, and load tao-theme.

#+BEGIN_SRC emacs-lisp
  (let ((theme-packages '(parchment-theme purple-haze-theme soothe-theme twilight-theme base16-theme zenburn-theme solarized-theme birds-of-paradise-plus-theme gruvbox-theme anti-zenburn-theme creamsody-theme doom-themes)))
    (mapc #'straight-use-package theme-packages)) 

  (straight-use-package 'olivetti)
  (straight-use-package 'all-the-icons)

  (use-package tao-theme
	       :straight t
	       :init
	       (load-theme 'tao-yang t))
#+END_SRC

    Theme picker. I can add themes I like the the list =tokamach/themes= and choose from them when I want. I realised I changed themes quite a lot, not least in the morning and evening I switch between a light and dark theme.

#+BEGIN_SRC emacs-lisp
  (defvar tokamach/themes '(
			    ;; Dark Themes
			    base16-atlas
			    purple-haze
			    soothe

			    ;; Light Themes
			    base16-atelier-estuary-light
			    parchment
			    plan9
			    anti-zenburn))

  (defun tokamach/pick-theme ()
    "Present a list of themes for user to pick"
    (interactive)
    (ivy-read
     "Pick theme:"
     tokamach/themes 
     :require-match t
     ;; :initial-input (car custom-enabled-themes)
     :action (lambda (theme)
	       (progn ;; (mapc #'disable-theme custom-enabled-themes)
		 (dolist (i custom-enabled-themes) (disable-theme i))
		 (load-theme (intern theme) t)
		 (fringe-mode 0)))
     :update-fn (lambda ()
		  (progn (mapc #'disable-theme custom-enabled-themes)
			 (load-theme (nth ivy--index tokamach/themes) t)
			 (fringe-mode 0)))))
#+END_SRC

    Of course at startup we still want an actual theme to be loaded.

#+BEGIN_SRC emacs-lisp
  ;(load-theme 'parchment t)
#+END_SRC

    Setting the font is pretty self explanatory. I've used Anonymous Pro for ages, it's pretty good at distinguishing 0/o, i/L, etc.

#+BEGIN_SRC emacs-lisp
  ;; fonts
  (set-frame-font "Anonymous Pro 13" nil t)
#+END_SRC

    This sections a doozy. Welcome to emacs in the 21st century. Basically we just have to disable all the ugly stuff emacs has by default, like menu bars. Who needs 'em. I have M-x, I have keybinds. Visible bell aka /SHUT THE FUCK UP EMACS/, inhibit startup because I know I'm using /"GNU Emacs, one component of the GNU/Linux operating system"/, turn off scroll bars and the weird fringes. Also =doom-modeline= makes the modeline look all nice.

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
  (setq visible-bell t)
  (setq ring-bell-function 'ignore)
  (setq initial-scratch-message "")
  (setq inhibit-startup-message t)
  (tool-bar-mode 0)
  (menu-bar-mode 0)
  (scroll-bar-mode 0)
  (fringe-mode 0)
  (setq frame-title-format "%b")

  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  ;(add-to-list 'default-frame-alist '(ns-appearance . dark))
  (add-to-list 'default-frame-alist '(ns-appearance . light))

  ;; better modeline
  (straight-use-package 'doom-modeline)
  (require 'doom-modeline)
  (doom-modeline-mode 1)
#+END_SRC

*** Homepage
Opening emacs only to be greeted by a blank =*scratch*= isn't fun. How about a cool startup page.

#+BEGIN_SRC emacs-lisp
  (use-package dashboard
    :straight t)
  (require 'dashboard)

  (let ((imgs (file-expand-wildcards (concat user-emacs-directory "/dashboard-images/*.png")))
	(random-choice (lambda (elems)
			 (let* ((size (length elems))
				(index (random size)))
			   (nth index elems)))))
    (setq dashboard-startup-banner (funcall random-choice imgs)))

  (setq dashboard-banner-logo-title "You're slacking off instead of writing Lisp? Pretty cringe bro.")
  (setq dashboard-center-content t)
  (setq show-week-agenda-p t)
  (setq dashboard-items '((recents  . 5)
			  (agenda   . 5)
			  (projects . 5)))

  (dashboard-setup-startup-hook)
  (setq inital-buffer-choice (lambda () (get-buffer "*dashboard*")))
#+END_SRC

*** Editor functionality
    Most of this is pretty self-explanatory. Tramp wants to use ssh, ispell exists actually (thanks macOS for being macOS), smooth scrolling is nice, undo-tree everywhere, oh and please stop spewing backup files all over my file system.

#+BEGIN_SRC emacs-lisp
  ;; tramp
  (setq tramp-default-method "ssh")

  ;; flyspell
  (setq ispell-program-name "/usr/local/bin/ispell")

  ;; smooth scroll
  (straight-use-package 'smooth-scrolling)
  (require 'smooth-scrolling)
  (smooth-scrolling-mode 1)

  (straight-use-package 'undo-tree)
  (global-undo-tree-mode)

  ;; stop backups
  (setq backup-inhibited t
	make-backup-files nil
	auto-save-default nil)
#+END_SRC

*** Editor key bindings
    Most of my more specific key bindings are stored in =modal-soul.el=, a set of hydras which simulate a kind of modal-editing system ala vim. Other stuff here is just avy and setting up the ivy/counsel/swiper trinity.

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'hydra)
  ;; modal-soul, my hydras
  (straight-use-package 'buffer-move)
  (load "~/.emacs.d/lisp/modal-soul.el")

  (straight-use-package 'which-key)
  (which-key-mode)

  ;; avy bindings
  ;; (global-set-key (kbd "C-l") 'avy-goto-line)
#+END_SRC

*** Ivy
    Ivy is a minibuffer completion framework, much nicer than the built in emacs completion. 
#+BEGIN_SRC emacs-lisp
  ;; ivy/counsel/swiper
  (straight-use-package 'counsel)
  (global-set-key "\C-s" 'swiper)
  (counsel-mode)
  (setq projectile-completion-system 'ivy)
#+END_SRC

*** Magit
#+BEGIN_SRC emacs-lisp
(straight-use-package 'magit)
#+END_SRC

*** Projectile
#+BEGIN_SRC emacs-lisp
(straight-use-package 'projectile)
#+END_SRC

*** Org mode
    Some nice lil packages.
#+BEGIN_SRC emacs-lisp
(straight-use-package 'org-bullets)
(straight-use-package 'org-sidebar)
#+END_SRC

    Org agenda would annoyingly mess up your windows and then not put them back. Be more like your respectable tidy brother magit.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-restore-windows-after-quit 1)
  (setq org-hide-emphasis-markers t)
  (setq org-directory "~/doc/org/")
  (setq org-default-notes-file (concat org-directory "capture.org"))

  (custom-theme-set-faces
   'user
   '(variable-pitch ((t (:family "New York" :height 140 :weight light))))
   '(fixed-pitch ((t (:family "Anonymous Pro" :slant normal :weight normal :height 1.0 :width normal)))))

  (add-hook 'org-mode-hook 'variable-pitch-mode)

  (require 'org-bullets)
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC

* Language Config
  Finally we've transformed the ancient magicks of emacs from a 50 year old dusty old expensive typewriter into an elegant tool to weave the fabric of code. Or something. Now we can get to our language specific config and hooks. 

*** C/C++
    The siblings who don't want to be associated with each other, lumped in to the same hook once again. By default emacs formats C in a bizarre GNU way. Cool, but not for me. Or whoever else has to read my C code.
    The mode hook was to set up eglot, but since that's proved very difficult in OS dev stuff, and my main C programming is for OS dev, I just disabled it until I can be bothered.
#+BEGIN_SRC emacs-lisp
  (setq c-default-style "linux"
	c-basic-offset 4)

  (defun tokamach/c-c++-hook ()
    "Personal C/C++ hook."
    (setq company-backends
	  (cons 'company-capf
		(remove 'company-capf company-backends)))
		(eglot-ensure))

  ;(add-hook 'c-mode-hook 'tokamach/c-c++-hook)
#+END_SRC

*** Lisps
    The language of the gods finally gets its turn. Do I want intelligent context dependent structural editing? *YES*. Do I want rainbows all over my parentheses? *YES*. Gimme that good shit.

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'geiser)
  (straight-use-package 'lispy)
  (straight-use-package 'rainbow-delimiters)

  (defun tokamach/lisp-hook ()
    "Personal Lisp hook."
    (lispy-mode)
    (rainbow-delimiters-mode)
    (show-paren-mode)
    (company-mode))

  (add-hook 'emacs-lisp-mode-hook  #'tokamach/lisp-hook)
  (add-hook 'common-lisp-mode-hook #'tokamach/lisp-hook)
  (add-hook 'scheme-mode-hook      #'tokamach/lisp-hook)
  (add-hook 'lisp-mode-hook        #'tokamach/lisp-hook)

  ;; Common Lisp
  (straight-use-package 'slime)
  (straight-use-package 'slime-company)
  (require 'slime)
  (setq inferior-lisp-program "/usr/local/bin/sbcl")
  (slime-setup '(slime-fancy slime-company))
#+END_SRC

*** Latex
    This is really just wrestling with macOS. AuCTeX is really good out of the box.

#+BEGIN_SRC emacs-lisp
(straight-use-package 'auctex)
(straight-use-package 'latex-pretty-symbols)
(straight-use-package 'exec-path-from-shell)

(exec-path-from-shell-initialize)
(setq TeX-parse-self t) ; Enable parse on load.
(setq TeX-auto-save t) ; Enable parse on save.
#+END_SRC
*** Matlab
    Urgh, matlab. At least its not too bad to use from within Emacs. We've gotta tell matlab-mode where the matlab binary is, and then we get to use the shell and eval like features in Emacs.

#+BEGIN_SRC emacs-lisp
(straight-use-package 'matlab-mode)
(setq matlab-shell-command "/Applications/MATLAB_R2019a.app/bin/matlab")
(setq matlab-shell-command-switches (list "-nodesktop"))
#+END_SRC
